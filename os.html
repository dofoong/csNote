<section id="os">
  <h2>6️⃣ 운영체제 & 시스템</h2>

  <!-- 45. 프로세스 vs 스레드 -->
  <article id="q45">
    <h3>🧩 45. 프로세스 vs 스레드</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      <b>프로세스</b>는 실행 중인 프로그램의 인스턴스로, 독립된 메모리 공간을 가집니다.  
      반면 <b>스레드</b>는 프로세스 내에서 실행되는 <b>작업 단위</b>로,  
      같은 프로세스 내의 메모리를 공유하기 때문에 <b>경량화</b>되어 있습니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>프로세스: 독립된 메모리 공간, Context Switching 비용 큼</li>
      <li>스레드: 같은 메모리 공간 공유, 효율적이지만 동기화 필요</li>
      <li>멀티프로세스는 안정성 ↑ / 멀티스레드는 효율 ↑</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      웹 서버(Nginx)는 멀티프로세스 구조를, 애플리케이션 서버(Spring)는 멀티스레드 구조를 사용합니다.  
      이는 요청 단위 병렬 처리와 안정성의 균형을 맞추기 위한 설계입니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>프로세스는 “독립성”, 스레드는 “효율성” — 서버는 둘을 적절히 섞어 쓴다.</blockquote>
    <hr />
  </article>


  <!-- 46. 컨텍스트 스위칭 -->
  <article id="q46">
    <h3>🧩 46. 컨텍스트 스위칭(Context Switching)</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      컨텍스트 스위칭은 CPU가 한 스레드에서 다른 스레드로 전환할 때,  
      현재 상태(레지스터, 스택, 프로그램 카운터 등)를 저장하고 복원하는 과정입니다.  
      이 작업은 필연적으로 <b>CPU 오버헤드</b>를 발생시킵니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>멀티태스킹을 가능하게 하는 핵심 기술</li>
      <li>스케줄러가 CPU 자원을 공정하게 배분</li>
      <li>스위칭이 잦으면 성능 저하 발생</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      자바 서버의 <b>ThreadPoolExecutor</b> 설정에서 스레드 수를 너무 많이 늘리면,  
      실제 CPU는 대부분 컨텍스트 스위칭에 소비됩니다.  
      그래서 “스레드 수 ≤ CPU 코어 × 2”가 일반적 기준입니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>컨텍스트 스위칭은 멀티스레드의 대가 — 많을수록 느려진다.</blockquote>
    <hr />
  </article>


  <!-- 47. 메모리 구조 -->
  <article id="q47">
    <h3>🧩 47. 메모리 구조 (Stack / Heap / Static / Code)</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      프로그램의 메모리는 크게 Code, Stack, Heap, Static 영역으로 나뉩니다.  
      Stack은 지역 변수와 함수 호출 정보를 저장하고,  
      Heap은 <b>동적으로 생성된 객체(new)</b>가 저장됩니다.  
      Static은 클래스 단위로, Code는 실행 코드가 위치합니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>Stack: 메서드 호출, 지역 변수 (LIFO 구조)</li>
      <li>Heap: 동적 객체 (GC 관리 대상)</li>
      <li>Static: 전역 변수, 클래스 변수</li>
      <li>Code: 실행 명령어 저장</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      Spring 애플리케이션에서 <code>new</code>로 생성된 객체는 Heap에 할당되며,  
      <b>GC(Garbage Collector)</b>가 주기적으로 메모리를 회수합니다.  
      StackOverflowError는 재귀 호출로 Stack 영역이 초과될 때 발생합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>Stack은 잠깐, Heap은 오래 — GC는 Heap을 청소한다.</blockquote>
    <hr />
  </article>


  <!-- 48. 가비지 컬렉션 (GC) -->
  <article id="q48">
    <h3>🧩 48. Garbage Collection (GC)</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      GC는 Heap 메모리에서 더 이상 참조되지 않는 객체를 자동으로 해제하는 기능입니다.  
      자바의 GC는 <b>Stop-the-world</b>를 동반하며,  
      Young Generation과 Old Generation으로 나눠 효율적으로 관리합니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>Young: 새 객체 (Eden + Survivor)</li>
      <li>Old: 오래된 객체 (Promotion)</li>
      <li>GC 알고리즘: Mark & Sweep, G1GC, ZGC 등</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>// JVM 옵션
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200</code></pre>

    <p>
      G1GC는 대규모 Heap에서도 짧은 중단 시간으로 GC를 수행합니다.  
      실무에서는 GC 로그를 분석하여 Pause Time과 Throughput을 조정합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>GC는 자동 청소부지만, 청소 타이밍은 튜닝의 예술이다.</blockquote>
    <hr />
  </article>


  <!-- 49. CPU 스케줄링 -->
  <article id="q49">
    <h3>🧩 49. CPU 스케줄링 알고리즘</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      CPU 스케줄링은 여러 프로세스가 동시에 실행될 때  
      어떤 프로세스에 CPU를 할당할지 결정하는 알고리즘입니다.  
      시스템 목적(응답속도, 처리량, 대기시간)에 따라 다양한 방식이 존재합니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>FCFS (First Come First Serve)</li>
      <li>SJF (Shortest Job First)</li>
      <li>RR (Round Robin) — 타임 슬라이스 기반</li>
      <li>Priority Scheduling — 우선순위 기반</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      운영체제는 내부적으로 “CPU 바운드 vs I/O 바운드” 프로세스를 구분해  
      효율적으로 CPU를 배분합니다.  
      Java Thread 스케줄링도 OS 레벨 스케줄러에 의존합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>스케줄링은 CPU의 교통정리 — 목적에 따라 알고리즘이 달라진다.</blockquote>
    <hr />
  </article>


  <!-- 50. Deadlock -->
  <article id="q50">
    <h3>🧩 50. 교착상태 (Deadlock)</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      교착상태는 두 개 이상의 스레드가 서로의 자원을 기다리며  
      <b>무한 대기</b>에 빠지는 현상입니다.  
      주로 synchronized 블록이나 DB 락에서 발생합니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>상호 배제 (Mutual Exclusion)</li>
      <li>점유와 대기 (Hold and Wait)</li>
      <li>비선점 (No Preemption)</li>
      <li>순환 대기 (Circular Wait)</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      스프링 트랜잭션에서 DB 락 순서를 다르게 접근하면 Deadlock이 발생할 수 있습니다.  
      해결 방법은 <b>락 순서 일관성 유지</b> 또는 <b>타임아웃 설정</b>입니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>Deadlock은 “서로 양보 없는 기다림” — 순서만 맞춰도 대부분 예방된다.</blockquote>
    <hr />
  </article>

  <footer>
    <p style="text-align:center; color:#888;">© 2025 도훈 김 — Coffee Chat 면접 대비 노트</p>
  </footer>
</section>
