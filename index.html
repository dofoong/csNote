<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>도훈 김 - 커피챗 면접 대비 종합노트</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="./css/style.css">
</head>

<body>
  <nav id="sidebar">
    <h3>📘 커피챗 면접 대비 노트</h3>
    <div id="menu"></div>
  </nav>

  <main id="content">
    <h2>👋 도훈 김 - 커피챗 면접 대비 종합노트</h2>
    <p>이 문서는 자바, 스프링, JPA, 네트워크, 운영체제, 시스템 설계 등
       커피챗(실무 면접)을 대비하기 위한 50문항 정리본입니다.</p>
    <ul>
      <li>왼쪽 메뉴에서 파트를 클릭하면 해당 섹션이 오른쪽에 표시됩니다.</li>
      <li>GitHub Pages 환경에서 fetch로 각 HTML을 로드합니다.</li>
    </ul>
    <hr />
  </main>
  <script>
/* ================================
   📘 Coffee Chat 면접 노트 스크립트
   ================================ */

const menuData = [
  {
    id: "java",
    title: "1️⃣ 자바 기본 & 메모리",
    file: "java.html",
    questions: [
      { id: "q1", title: "Primitive vs Reference" },
      { id: "q2", title: "JVM 구조" },
      { id: "q3", title: "Stack vs Heap" },
      { id: "q4", title: "String 불변성" },
      { id: "q5", title: "Wrapper Class" },
      { id: "q6", title: "equals() vs ==" },
      { id: "q7", title: "HashMap vs Hashtable" },
      { id: "q8", title: "HashMap의 시간복잡도" },
      { id: "q9", title: "ConcurrentHashMap 원리" },
      { id: "q10", title: "ArrayList vs LinkedList" }
    ]
  },
  {
    id: "thread",
    title: "2️⃣ 스레드 & 동시성",
    file: "thread.html",
    questions: [
      { id: "q11", title: "Thread vs Runnable" },
      { id: "q12", title: "synchronized 키워드" },
      { id: "q13", title: "volatile 키워드" },
      { id: "q14", title: "ThreadLocal" },
      { id: "q15", title: "Deadlock" },
      { id: "q16", title: "ExecutorService" },
      { id: "q17", title: "Future와 CompletableFuture" },
      { id: "q18", title: "Thread-safe 설계" }
    ]
  },
  {
    id: "spring",
    title: "3️⃣ 스프링 핵심",
    file: "spring.html",
    questions: [
      { id: "q19", title: "IoC와 DI" },
      { id: "q20", title: "AOP 개념" },
      { id: "q21", title: "@Transactional 동작 원리" },
      { id: "q22", title: "빈 생명주기" },
      { id: "q23", title: "Bean Scope" },
      { id: "q24", title: "프록시(Proxy) 구조" },
      { id: "q25", title: "DispatcherServlet" },
      { id: "q26", title: "Controller vs RestController" },
      { id: "q27", title: "Exception 처리 구조" }
    ]
  },
  {
    id: "db",
    title: "4️⃣ DB & JPA",
    file: "db.html",
    questions: [
      { id: "q28", title: "인덱스(Index)" },
      { id: "q29", title: "인덱스의 단점" },
      { id: "q30", title: "트랜잭션 ACID" },
      { id: "q31", title: "N+1 문제" },
      { id: "q32", title: "Fetch Join" },
      { id: "q33", title: "LAZY vs EAGER" },
      { id: "q34", title: "정규화" },
      { id: "q35", title: "트랜잭션 필요성" },
      { id: "q36", title: "쿼리 성능 튜닝" }
    ]
  },
  {
    id: "network",
    title: "5️⃣ 네트워크 & HTTP",
    file: "network.html",
    questions: [
      { id: "q37", title: "HTTP vs HTTPS" },
      { id: "q38", title: "GET vs POST" },
      { id: "q39", title: "REST API" },
      { id: "q40", title: "Stateless의 의미" },
      { id: "q41", title: "쿠키 vs 세션 vs JWT" },
      { id: "q42", title: "CORS" },
      { id: "q43", title: "HTTP 상태코드" },
      { id: "q44", title: "로드밸런싱" }
    ]
  },
  {
    id: "os",
    title: "6️⃣ 운영체제 & 시스템",
    file: "os.html",
    questions: [
      { id: "q45", title: "프로세스 vs 스레드" },
      { id: "q46", title: "컨텍스트 스위칭" },
      { id: "q47", title: "메모리 구조" },
      { id: "q48", title: "Garbage Collection" },
      { id: "q49", title: "CPU 스케줄링" },
      { id: "q50", title: "Deadlock" }
    ]
  }
];

const menu = document.getElementById("menu");
const main = document.getElementById("content");

// ===============================
// 📂 사이드바 메뉴 렌더링
// ===============================
menu.innerHTML = menuData.map(sec => `
  <div class="section" data-id="${sec.id}" data-file="${sec.file}">
    <div class="section-title">${sec.title}</div>
    <ul class="sublist hidden">
      ${sec.questions.map(q => `<li class="question" data-qid="${q.id}">${q.title}</li>`).join("")}
    </ul>
  </div>
`).join("");

// ===============================
// 🖱️ 메뉴 클릭 이벤트
// ===============================
menu.addEventListener("click", async e => {
  const section = e.target.closest(".section");

  // 1️⃣ 상위 섹션 클릭 → HTML 불러오기 + 하위 목록 토글
  if (e.target.classList.contains("section-title")) {
    const file = section.dataset.file;
    const sublist = section.querySelector(".sublist");

    // 다른 섹션 접기
    document.querySelectorAll(".sublist").forEach(el => el.classList.remove("show"));

    // 클릭한 섹션만 펼치기
    sublist.classList.toggle("show");

    // HTML fetch
    const res = await fetch(file);
    const html = await res.text();
    main.innerHTML = html;
    main.scrollTo({ top: 0, behavior: "smooth" });
  }

  // 2️⃣ 하위 문제 클릭 → 스크롤 이동
  if (e.target.classList.contains("question")) {
    const qid = e.target.dataset.qid;
    const el = main.querySelector(`#${qid}`);
    if (el) {
      el.scrollIntoView({ behavior: "smooth", block: "start" });
      document.querySelectorAll(".question").forEach(li => li.classList.remove("active"));
      e.target.classList.add("active");
    }
  }
});

</script>

</body>
</html>
