<section id="java-basics">
  <h2>1️⃣ 자바 기본 & 메모리 구조</h2>

  <article id="q1">
    <h3>🧩 1. Stack과 Heap의 차이</h3>
    <h4>🪄 기초</h4>
    <ul>
      <li><b>Stack</b>: 함수 호출 시 지역 변수나 매개변수를 저장하는 임시 공간.</li>
      <li><b>Heap</b>: <code>new</code>로 생성된 객체가 저장되는 공간.</li>
    </ul>
    <blockquote>Stack은 빠르지만 휘발성, Heap은 느리지만 오래 저장.</blockquote>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>Stack은 <b>LIFO</b> 구조로 메서드 호출마다 프레임 생성/소멸.</li>
      <li>Heap은 <b>GC(Garbage Collector)</b>가 관리하며 참조 끊기면 제거.</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li><b>StackOverflowError</b> → 재귀 호출 과다 시 발생.</li>
      <li><b>OutOfMemoryError</b> → Heap 객체 과다 생성 시 발생.</li>
      <li>실무 팁: 대량 객체는 지역변수 참조를 빨리 끊어 GC 유도.</li>
    </ul>
    <hr />
  </article>

  <article id="q2">
    <h3>🧩 2. JVM 메모리 구조</h3>
    <h4>🪄 기초</h4>
    <p><b>JVM(Java Virtual Machine)</b> 위에서 자바 프로그램이 동작하며,
      프로그램 실행을 위한 메모리를 여러 영역으로 나눈다.</p>

    <h4>⚙️ 핵심</h4>
    <table>
      <tr><th>영역</th><th>역할</th></tr>
      <tr><td>Method Area</td><td>클래스, static 변수 저장</td></tr>
      <tr><td>Heap</td><td>객체 저장</td></tr>
      <tr><td>Stack</td><td>호출된 메서드의 지역 변수/프레임</td></tr>
      <tr><td>PC Register</td><td>현재 실행 명령어 주소</td></tr>
      <tr><td>Native Method Stack</td><td>JNI 등 네이티브 코드 실행용</td></tr>
    </table>

    <h4>🔬 심화</h4>
    <ul>
      <li>Heap, PermGen, Stack 크기 튜닝 가능.</li>
      <li>JDK8 이후 PermGen → Metaspace 변경.</li>
      <li>Heap 내 참조 유지 객체로 메모리 누수 발생.</li>
    </ul>
    <hr />
  </article>

  <article id="q3">
    <h3>🧩 3. Garbage Collection(GC)</h3>
    <h4>🪄 기초</h4>
    <p><b>GC</b>는 불필요한 객체를 자동으로 제거하는 기능.</p>
    <blockquote>자바는 <code>delete</code>가 없으며 JVM이 자동 청소.</blockquote>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>GC Root에서 도달 불가능한 객체 제거.</li>
      <li>Young/Old 세대 구조로 관리, Young부터 자주 청소.</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li><b>Stop-the-world</b>: GC 중 스레드 일시 정지.</li>
      <li><b>Minor GC</b>/ <b>Full GC</b>: Young/Old 영역 청소 구분.</li>
      <li><b>G1, ZGC, Shenandoah</b>: 최신 GC는 멈춤 최소화.</li>
      <li>Full GC 잦을 시 메모리 튜닝 필요.</li>
    </ul>
    <hr />
  </article>

  <article id="q4">
    <h3>🧩 4. static 메서드와 인스턴스 메서드의 차이</h3>
    <h4>🪄 기초</h4>
    <ul>
      <li><b>static</b>: 클래스에 속하며 객체 생성 없이 접근 가능.</li>
      <li><b>인스턴스 메서드</b>: 객체마다 동작 다름.</li>
    </ul>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>static 멤버 → Method Area 저장.</li>
      <li>인스턴스 멤버 → Heap 내부 존재.</li>
      <li>공통 데이터나 유틸성 함수에 static 활용.</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li>static은 캡슐화/다형성 제한 가능.</li>
      <li>Spring Bean 주입은 대부분 static 아님.</li>
      <li>멀티스레드 환경에선 static 공유 동기화 필요.</li>
    </ul>
    <hr />
  </article>

  <article id="q5">
    <h3>🧩 5. String의 불변(Immutable)성</h3>
    <h4>🪄 기초</h4>
    <p>"String은 한 번 만들면 바꿀 수 없다." 예: <code>"abc" → "abcde"</code>는 새 객체 생성.</p>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>문자열 리터럴 캐싱(String Pool)</li>
      <li>Thread-safe</li>
      <li>보안 강화(URL, 비밀번호 등)</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li><code>"a" + "b"</code>는 새 객체 생성 (비효율).</li>
      <li><b>StringBuilder / StringBuffer</b>로 개선.</li>
      <li><b>String.intern()</b>으로 Pool 등록.</li>
    </ul>
    <hr />
  </article>
  <article id="q6">
    <h3>🧩 6. equals() vs ==</h3>
    <h4>🪄 기초</h4>
    <ul>
      <li><code>==</code> : 두 객체의 <b>참조(주소)</b>가 같은지 비교</li>
      <li><code>equals()</code> : 두 객체의 <b>값</b>이 같은지 비교</li>
    </ul>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>Object의 기본 <code>equals()</code>는 <code>==</code>와 동일하게 동작</li>
      <li>String, Integer 등은 <code>equals()</code>를 <b>값 비교용</b>으로 재정의</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li><b>equals()</b>를 재정의하면 반드시 <b>hashCode()</b>도 같이 재정의</li>
      <li>HashMap, HashSet 등은 hashCode()와 equals() 모두 사용</li>
      <li>실무 예시: <code>record</code>는 자동으로 equals/hashCode 생성</li>
    </ul>
    <hr />
  </article>

  <article id="q7">
    <h3>🧩 7. HashMap vs Hashtable</h3>
    <h4>🪄 기초</h4>
    <ul>
      <li><b>Hashtable</b> : 동기화(synchronized) 지원, null 불가</li>
      <li><b>HashMap</b> : 비동기, null 허용</li>
    </ul>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>HashMap이 Hashtable보다 빠르고 현대적</li>
      <li>Hashtable은 JDK 1.0 유산, 현재는 <b>ConcurrentHashMap</b>으로 대체</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li>Hashtable은 전체 메서드에 synchronized → 병목 발생</li>
      <li>ConcurrentHashMap은 세그먼트 락 or CAS 기반으로 병렬 성능 향상</li>
      <li>HashMap은 멀티스레드 환경에서 unsafe</li>
    </ul>
    <hr />
  </article>

  <article id="q8">
    <h3>🧩 8. HashMap의 시간복잡도</h3>
    <h4>🪄 기초</h4>
    <ul>
      <li>평균적으로 <b>O(1)</b></li>
      <li>충돌(collision) 발생 시 <b>O(n)</b></li>
    </ul>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>내부적으로 <b>배열 + 연결리스트</b>로 구성</li>
      <li>key의 hashCode()로 인덱스 계산</li>
      <li>JDK 8 이후 충돌이 많으면 <b>트리(TreeNode)</b>로 변환</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li>TreeNode 변환 시 시간복잡도 O(log n)</li>
      <li>적절한 해시 함수 설계로 균등 분포 유지 중요</li>
      <li>resize 과정에서 O(n) 부하 → 초기 capacity 설정이 중요</li>
    </ul>
    <hr />
  </article>

  <article id="q9">
    <h3>🧩 9. ConcurrentHashMap 원리</h3>
    <h4>🪄 기초</h4>
    <ul>
      <li>멀티스레드 환경에서 <b>thread-safe</b>한 HashMap</li>
    </ul>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>JDK 7 이전: 세그먼트 락(Segment Lock)</li>
      <li>JDK 8 이후: CAS(Compare-And-Swap) + synchronized 블록 병용</li>
      <li>전체 락 대신 부분 락으로 병렬성 향상</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li>읽기(read)는 락 없이 가능 → 높은 처리량</li>
      <li>쓰기(write)는 bin 단위로 synchronized</li>
      <li>key 충돌 시 bin tree 구조로 동기화 최소화</li>
    </ul>
    <hr />
  </article>

  <article id="q10">
    <h3>🧩 10. ArrayList vs LinkedList</h3>
    <h4>🪄 기초</h4>
    <ul>
      <li><b>ArrayList</b> : 내부적으로 배열 기반</li>
      <li><b>LinkedList</b> : 노드 기반 (이전/다음 포인터)</li>
    </ul>

    <h4>⚙️ 핵심</h4>
    <ul>
      <li>ArrayList → 탐색 빠름 (O(1)) / 삽입·삭제 느림 (O(n))</li>
      <li>LinkedList → 탐색 느림 (O(n)) / 삽입·삭제 빠름 (O(1))</li>
      <li>임시 저장용, 인덱스 접근 많을 때는 ArrayList 선호</li>
    </ul>

    <h4>🔬 심화</h4>
    <ul>
      <li>대량 데이터 처리 시 ArrayList가 캐시 효율 높음</li>
      <li>LinkedList는 메모리 오버헤드가 큼</li>
      <li>Queue/Deque 용도로는 LinkedList가 유리</li>
    </ul>
    <hr />
  </article>
</section>

