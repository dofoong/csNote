<section id="java">
  <h2>1️⃣ 자바 기본 & 메모리 구조</h2>

  <!-- 1. Primitive vs Reference Type -->
  <article id="q1">
    <h3>🧩 1. 기본형(Primitive) vs 참조형(Reference)</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      자바의 변수는 크게 <b>기본형(Primitive)</b>과 <b>참조형(Reference)</b>으로 나뉩니다.  
      기본형은 값 자체를 저장하고, 참조형은 <b>객체의 주소를 참조</b>합니다.  
      기본형은 Stack에, 참조형은 Heap에 저장되는 구조입니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>Primitive: int, boolean, double 등 (값 저장)</li>
      <li>Reference: String, 배열, 클래스 등 (객체 주소 저장)</li>
      <li>기본형은 Stack, 참조형은 Heap에 위치</li>
      <li>Null 가능 여부: 기본형 ❌ / 참조형 ⭕</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>int a = 10;
Integer b = 10;
System.out.println(a == b); // true (auto-unboxing)
System.out.println(a.equals(b)); // ❌ (primitive에는 메서드 없음)</code></pre>

    <p>
      오토박싱/언박싱은 편리하지만 반복 연산 시 성능 저하를 유발할 수 있어,  
      <b>성능 민감한 코드에서는 기본형을 권장</b>합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>기본형은 값, 참조형은 주소 — Stack과 Heap의 차이를 이해하라.</blockquote>
    <hr />
  </article>


  <!-- 2. JVM 구조 -->
  <article id="q2">
    <h3>🧩 2. JVM 구조</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      JVM(Java Virtual Machine)은 자바 프로그램을 OS에 독립적으로 실행하기 위한 가상머신입니다.  
      코드가 <b>컴파일된 후 Bytecode 형태로 JVM에서 실행</b>되며,  
      내부적으로 Class Loader, Runtime Data Area, Execution Engine으로 구성됩니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>Class Loader: .class 파일 로드</li>
      <li>Runtime Data Area: Stack, Heap, Method Area 등</li>
      <li>Execution Engine: Bytecode를 기계어로 변환 (JIT 컴파일러)</li>
      <li>Garbage Collector: Heap 관리</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      JVM 구조를 이해하면 <b>OutOfMemoryError</b>, <b>GC 튜닝</b>, <b>클래스 로딩 오류</b> 같은 문제를 진단하기 쉬워집니다.  
      특히 대규모 서비스에서는 G1GC, ZGC 등 JVM 옵션 튜닝이 성능에 직접적 영향을 줍니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>JVM은 자바의 심장 — GC, 메모리, 실행 엔진을 이해해야 성능을 통제할 수 있다.</blockquote>
    <hr />
  </article>


  <!-- 3. Stack vs Heap -->
  <article id="q3">
    <h3>🧩 3. Stack vs Heap</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      Stack은 메서드 호출 시 생성되는 지역 변수와 호출 정보를 저장하고,  
      Heap은 <b>new로 생성한 객체</b>가 저장됩니다.  
      Stack은 자동으로 관리되지만, Heap은 GC가 관리합니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>Stack: 지역 변수, 메서드 프레임, LIFO 구조</li>
      <li>Heap: 객체 인스턴스 저장, GC 관리 대상</li>
      <li>StackOverflowError: 재귀 과다 호출 시 발생</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      대형 리스트나 Map 객체를 전역으로 유지할 경우 Heap을 압박하게 되고,  
      GC Pause Time이 증가해 서버 응답이 지연될 수 있습니다.  
      <b>불필요한 참조를 해제</b>하는 습관이 중요합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>Stack은 일시적, Heap은 지속적 — 메모리 누수는 Heap에서 시작된다.</blockquote>
    <hr />
  </article>


  <!-- 4. String 불변성 -->
  <article id="q4">
    <h3>🧩 4. String의 불변성(Immutable)</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      자바의 <b>String</b>은 불변 객체(Immutable)입니다.  
      즉, 한 번 생성된 문자열은 절대 변경되지 않으며,  
      문자열을 수정하면 새로운 객체가 생성됩니다.  
      이 특성 덕분에 <b>스레드 안전성</b>과 <b>해시 안정성</b>이 보장됩니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>String은 final class</li>
      <li>문자 변경 시 새로운 객체 생성</li>
      <li>String Pool로 재사용 (interning)</li>
      <li>StringBuilder/StringBuffer: 가변 문자열 클래스</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>String a = "Hello";
a += " World"; // 새로운 객체 생성
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World"); // 기존 객체 수정</code></pre>

    <p>
      반복 문자열 결합 시에는 반드시 <b>StringBuilder</b>를 사용해야 성능 손실을 막을 수 있습니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>String은 불변, Builder는 가변 — 반복 처리엔 StringBuilder가 필수다.</blockquote>
    <hr />
  </article>


  <!-- 5. Wrapper Class -->
  <article id="q5">
    <h3>🧩 5. Wrapper Class의 역할</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      Wrapper Class는 기본형을 객체로 다루기 위한 클래스입니다.  
      예를 들어 int → Integer, double → Double과 같이 감쌉니다.  
      이를 통해 컬렉션(List, Map 등)에서 기본형 데이터를 다룰 수 있습니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>오토박싱(Auto-boxing): 기본형 → 객체형 자동 변환</li>
      <li>언박싱(Unboxing): 객체형 → 기본형 자동 변환</li>
      <li>Wrapper 클래스는 null을 가질 수 있음</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>List<Integer> list = new ArrayList<>();
list.add(1); // auto-boxing 발생
int num = list.get(0); // unboxing 발생</code></pre>

    <p>
      반복 연산에서는 박싱/언박싱이 과도하게 일어나면 성능이 저하됩니다.  
      성능이 중요한 구간에서는 기본형 배열 사용이 유리합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>Wrapper는 “기본형의 객체화” — 컬렉션에서 기본형을 다루게 해준다.</blockquote>
    <hr />
  </article>


  <!-- 6. equals() vs == -->
  <article id="q6">
    <h3>🧩 6. equals() vs ==</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      <b>==</b>은 두 객체의 <b>참조(주소)</b>가 같은지 비교하고,  
      <b>equals()</b>는 객체의 <b>내용(값)</b>을 비교합니다.  
      단, equals()를 재정의하지 않으면 기본적으로 ==와 동일하게 동작합니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>== → 주소 비교</li>
      <li>equals() → 값 비교</li>
      <li>equals() 재정의 시 hashCode()도 반드시 재정의해야 함</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>String a = new String("Hi");
String b = new String("Hi");
System.out.println(a == b);       // false
System.out.println(a.equals(b));  // true</code></pre>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>==는 주소, equals는 값 — HashMap을 쓰려면 둘 다 맞춰야 한다.</blockquote>
    <hr />
  </article>

  <!-- 7. HashMap vs Hashtable -->
  <article id="q7">
    <h3>🧩 7. HashMap vs Hashtable</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      <b>HashMap</b>은 비동기 환경에서 빠른 성능을 제공하지만 thread-safe하지 않고,  
      <b>Hashtable</b>은 오래된 동기화 기반 컬렉션으로, 모든 메서드가 synchronized입니다.  
      요즘은 Hashtable 대신 <b>ConcurrentHashMap</b>을 사용합니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>HashMap: 비동기, null 허용, 성능 우수</li>
      <li>Hashtable: 동기화(synchronized) 적용, null 불가</li>
      <li>ConcurrentHashMap: 부분 락으로 동시성 개선</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>// Thread-safe하지 않은 HashMap
Map&lt;String, String&gt; map = new HashMap<>();

// 안전한 ConcurrentHashMap
Map&lt;String, String&gt; safeMap = new ConcurrentHashMap<>();</code></pre>

    <p>
      HashMap은 단일 스레드 환경에서 빠르고, Hashtable은 구식 동기화로 병목이 심합니다.  
      실제 서비스에서는 <b>ConcurrentHashMap</b>이 사실상 표준입니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>Hashtable은 과거형, HashMap은 기본형, ConcurrentHashMap은 실무형.</blockquote>
    <hr />
  </article>


  <!-- 8. HashMap의 시간복잡도 -->
  <article id="q8">
    <h3>🧩 8. HashMap의 시간복잡도</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      HashMap의 평균 접근 시간은 <b>O(1)</b>이지만, 해시 충돌이 많으면 <b>O(n)</b>까지 증가할 수 있습니다.  
      JDK 8 이후로는 충돌이 일정 수준을 넘으면 연결 리스트 대신 <b>트리 구조(TreeNode)</b>로 변경되어  
      최악의 경우도 <b>O(log n)</b>으로 보완됩니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>평균 접근: O(1)</li>
      <li>충돌 발생 시: O(n)</li>
      <li>JDK 8 이후 충돌 시 TreeNode로 변환 → O(log n)</li>
      <li>해시 분포 품질이 성능 핵심</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <p>
      해시 함수가 특정 구간에 몰리면 HashMap의 성능이 급격히 저하됩니다.  
      따라서 <b>hashCode()를 적절히 오버라이드</b>하는 것이 중요합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>HashMap의 성능은 해시 분포 품질에 달려 있다 — 평균 O(1), 최악 O(log n).</blockquote>
    <hr />
  </article>


  <!-- 9. ConcurrentHashMap 원리 -->
  <article id="q9">
    <h3>🧩 9. ConcurrentHashMap의 원리</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      <b>ConcurrentHashMap</b>은 HashMap에 락을 걸어 thread-safe하게 만든 컬렉션입니다.  
      하지만 전체 락이 아닌 <b>부분 락(Segment Lock)</b> 또는 CAS(Compare-And-Swap)를 사용해  
      동시성 성능을 높였습니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>JDK 7: 세그먼트 단위 락</li>
      <li>JDK 8: CAS + synchronized 혼합 구조</li>
      <li>읽기(read)는 락 없이 가능</li>
      <li>쓰기(write)는 bin 단위로 락</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap<>();
map.put("key", 1);
map.computeIfAbsent("key", k -> 2);</code></pre>

    <p>
      CAS 기반 덕분에 수십 개의 스레드가 동시에 put/get 연산을 수행해도 병목이 거의 없습니다.  
      그러나 복합 연산(add-if-absent-then-update)은 여전히 주의가 필요합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>ConcurrentHashMap은 “부분 락 + CAS”로 동시성과 성능을 모두 잡았다.</blockquote>
    <hr />
  </article>


  <!-- 10. ArrayList vs LinkedList -->
  <article id="q10">
    <h3>🧩 10. ArrayList vs LinkedList</h3>

    <h4>💬 면접 답변 예시</h4>
    <p>
      <b>ArrayList</b>는 내부적으로 배열을 사용하고, <b>LinkedList</b>는 노드 구조를 사용합니다.  
      ArrayList는 인덱스 접근이 빠르지만 중간 삽입/삭제가 느리고,  
      LinkedList는 삽입/삭제가 빠르지만 랜덤 접근이 느립니다.
    </p>

    <h4>🧠 핵심 개념</h4>
    <ul>
      <li>ArrayList: 배열 기반, O(1) 접근 / O(n) 삽입</li>
      <li>LinkedList: 노드 기반, O(n) 접근 / O(1) 삽입</li>
      <li>순차 추가, 인덱스 접근 많을 땐 ArrayList 유리</li>
      <li>Queue, Deque 용도로는 LinkedList 유리</li>
    </ul>

    <h4>⚙️ 실무 적용 예시</h4>
    <pre><code>List&lt;String&gt; arr = new ArrayList<>();
List&lt;String&gt; link = new LinkedList<>();

arr.add("A"); // 빠름
link.add(0, "A"); // 삽입엔 빠름</code></pre>

    <p>
      LinkedList는 객체 생성 오버헤드가 크기 때문에 대량 데이터에서는 ArrayList가 효율적입니다.  
      대부분의 컬렉션 API나 ORM 내부 구현은 ArrayList를 기본으로 사용합니다.
    </p>

    <h4>🪄 한 줄 요약</h4>
    <blockquote>ArrayList는 속도, LinkedList는 유연성 — 대부분의 경우 ArrayList가 기본이다.</blockquote>
    <hr />
  </article>
</section>
